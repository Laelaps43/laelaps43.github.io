<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on Laelaps</title>
    <link>https://blog.laelaps.us/categories/docker/</link>
    <description>Recent content in Docker on Laelaps</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 17 Mar 2025 00:56:49 +0000</lastBuildDate>
    <atom:link href="https://blog.laelaps.us/categories/docker/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>数据库事务</title>
      <link>https://blog.laelaps.us/posts/archive/database/transaction/</link>
      <pubDate>Mon, 14 Aug 2023 21:58:13 +0800</pubDate>
      <guid>https://blog.laelaps.us/posts/archive/database/transaction/</guid>
      <description>在一些情况下，如数据库在写入到一半数据时崩溃，在或者多个客户端同时向数据库中相同的位置写入不同的数据，如果我们只在应用层面解决这些问题，似乎变得繁琐，而事务简化了这些操作，他将多个操作组合成一个集合，这个集合要不全部执行成功，要不全部失败。事务有着ACID的属性。&#xA;原子性（Atomicity） 事务有多个操作组合，那么这一些列的操作，要不全部执行，要不都不执行；如果一个事务不具备原子性，那就没有办法保证同一个事务中的所有操作都被执行或者未被执行。&#xA;在数据库发生异常时，要想保证事务的原子性，那么就要对已经执行的操作进行回滚；在MySQL中，恢复机制是通过回滚日志（undo log）来实现的，所有事务在进行修改都会先记录到这个回滚日志中，然后在对数据库进行对应的写入。&#xA;回滚日志除了在发生错误或者用户执行ROLLBACK时提供回滚相关的信息，还能在数据库崩溃、数据库进程被杀死后，当用户重新启动数据库时，能够通过查询回滚日志将之前未完成的事务进行回滚，所以回滚日志必须先于数据库持久化到磁盘上，即先写日志后写数据库；值得注意的是，回滚日志并不是将数据库物理的恢复到执行语句或事务之前的样子，而是按照日志生成对应的反操作进行撤销。&#xA;持久性（Durability） 持久性是指一旦事务被提交，那么数据就一定会被写入到数据库中并持久存储起来；数据被存储到数据库中，那么数据一定会被安全的存储在磁盘上。&#xA;如果事务被提交之后，那么就无法再次回滚了，能后撤销的就是对已经提交的事务创建一个相反的事务。&#xA;事务的持久性是依靠日志来实现的，MySQL使用重做日志（redo log）来实现事务的持久性；当一个事务尝试对数据进行修改是，他会先将数据从磁盘中读入内存，并在内存中更新缓存的数据，如何生成一条重做日志并写入日志缓存中，当事务真正提交时，MySQL会将重做日志缓存中的内容写入到重做文件，再将内存中的数据写入磁盘中；除了事务外，所有对数据库的操作都会产生重做日志，当数据库发生错误的时候，数据库重启会从重做日志中找出未被更新到数据库磁盘中的日志重新执行。&#xA;在InnoDB中，重做日志都是以512字节的块的形式存储的，因为块的大小跟磁盘扇区的大小系统，所以重做日志的写入可以保证原子性，不会由于机器的断电导致重做日志仅写入一半并留下脏数据。 回滚日志和重做日志 在MySQL中，事务的原子性和持久性是由事务日志（transaction log）保证的，也就是回滚日志和重做日志来实现，前者对事务的影响进行撤销，后者在错误处理时对已经提交的事务进行重做。&#xA;隔离性（Isolation） 事务的隔离性是指在并发执行的事务之间不互相干扰，因为如果对一个数据有多个事务（T1，T2，T3 &amp;hellip;）同时执行，这是如果T1在操作一段时间后，T2同时去读取数据并提交事务，但是这是T1发生撤销，那么这时发生了错误；当然我们可以只有当T1提交后，T2才能提交，接着T3提交，若是撤销的话，则是发生级联回滚，这些串行并不难得到资源的利用率。&#xA;隔离级别 在多个事务并发执行时，对单个事务的执行没有影响，但是对数据库总体来说会造成数据库的一致性问题；所以开发者得平衡两者之间的关系，并行可以很好的维护数据库的一致性，但是会影响事务的并行性能。&#xA;在数据库中的事务隔离级别分为：READ UNCOMMITED、READ COMMITED、REPEATABLE READ 和 SERIALIZABLE；&#xA;READ UNCOMMITED：使用查询语句不会加锁，可能会读到未提交的行（Dirty Read） READ COMMITED：只对查询加锁，而不在查询之间的间隙加锁，所以允许在这间隔中修改数据，在多次查询时，得到的数据可能得到不同的结果（Non-Repeatable Read） REPEATABLE READ：第一次查询时，会保存查询的快照，在之后的查询都从快照中读取。不会返回不同的数据，但是会出现幻读（Phantom Read） SERIALIZABLE：再全部的查询语句都加上了共享锁，解决了幻读，代价最高 脏读（Dirty Read）：在一个事务中，读取了其他事务未提交的数据 不可重复读（Non-Repeatable Read）：在一个事务中，同一行记录被访问了两次却得到了不同的结果 幻读（Phantom Read）：在一个事务中，同一个范围内的记录被读取时，其他事务向这个范围添加了新的记录 隔离级别实现 锁 共享锁（Shared）和互斥锁（Exclusive），也叫读锁和写锁，读锁保证了读操作可以并发执行，不会相互影响，写锁保证了在更新数据时不会有其他的事务访问或者更改了同一条记录不会造成不可预知的问题。&#xA;时间戳 读时间戳中包括了所有访问该记录的事务中的最大时间戳，而记录行的写时间戳中保存了将记录改到当前值的事务的时间戳。使用时间戳实现事务的隔离性时，往往都会使用乐观锁，先对数据进行修改，在写回时再去判断当前值，也就是时间戳是否改变过，如果没有改变过，就写入，否则，生成一个新的时间戳并再次更新数据，乐观锁其实并不是真正的锁机制，它只是一种思想。&#xA;多版本和快照隔离 通过维护多个版本的数据，数据库可以允许事务在数据被其他事务更新时对旧版本的数据进行读取；很多数据库都对这一机制进行了实现；因为所有的读操作不再需要等待写锁的释放，所以能够显著地提升读的性能，MVCC。&#xA;一致性（Consistent） ACID 如果一个事务原子地在一个一致地数据库中独立运行，那么在它执行之后，数据库的状态一定是一致的。对于这个概念，它的第一层意思就是对于数据完整性的约束，包括主键约束、引用约束以及一些约束检查等等，在事务的执行的前后以及过程中不会违背对数据完整性的约束，所有对数据库写入的操作都应该是合法的，并不能产生不合法的数据状态。&#xA;数据库 ACID 中的一致性对事务的要求不止包含对数据完整性以及合法性的检查，还包含应用层面逻辑的正确（对开展在逻辑上的要求）。&#xA;CAP CAP 定理中的数据一致性，其实是说分布式系统中的各个节点中对于同一数据的拷贝有着相同的值；</description>
    </item>
    <item>
      <title>Docker网络</title>
      <link>https://blog.laelaps.us/posts/archive/docker/network/</link>
      <pubDate>Sun, 13 Aug 2023 14:07:23 +0800</pubDate>
      <guid>https://blog.laelaps.us/posts/archive/docker/network/</guid>
      <description>网络 在安装Docker时，会自动创建三个网络。&#xA;➜ ~ sudo docker network ls NETWORK ID NAME DRIVER SCOPE 2ddeffb91230 bridge bridge local c55e5f5ed788 host host local 1eebd0c8e7c7 none null local 在Docker中有三种模式，分别为bridg、host和null 。&#xA;Bridge模式 在Docker启动时，Docker会在宿主中创建一个为Docker0的虚拟网口，Docker会为这个虚拟网口分配一个虚拟网段，在每次启动一个服务时，那么就会分配docker0的一个子网给容器，那么容器就可以访问宿主和外网；同时他会进行NAT转换；在同一个bridge下的所有设备都可以相互通信，我们也可以将他们之间设置为禁止通信。 # 创建一个容器，自动加入bridge网桥 ➜ ~ sudo docker run -d --name ron1 praqma/network-multitool 我们可以查看一个bridge的信息。&#xA;➜ ~ sudo docker network inspect bridge [ { &amp;#34;Name&amp;#34;: &amp;#34;bridge&amp;#34;, &amp;#34;Id&amp;#34;: &amp;#34;2ddeffb91230eb06f738dc5ca7be5e853f82fa8324e338c592424e1b478e5571&amp;#34;, &amp;#34;Created&amp;#34;: &amp;#34;2023-08-14T00:53:05.367734129+08:00&amp;#34;, &amp;#34;Scope&amp;#34;: &amp;#34;local&amp;#34;, &amp;#34;Driver&amp;#34;: &amp;#34;bridge&amp;#34;, &amp;#34;EnableIPv6&amp;#34;: false, &amp;#34;IPAM&amp;#34;: { &amp;#34;Driver&amp;#34;: &amp;#34;default&amp;#34;, &amp;#34;Options&amp;#34;: null, &amp;#34;Config&amp;#34;: [ { &amp;#34;Subnet&amp;#34;: &amp;#34;172.</description>
    </item>
    <item>
      <title>Docker数据持久化</title>
      <link>https://blog.laelaps.us/posts/archive/docker/volumes/</link>
      <pubDate>Sat, 12 Aug 2023 21:23:53 +0800</pubDate>
      <guid>https://blog.laelaps.us/posts/archive/docker/volumes/</guid>
      <description>数据管理 在Docker内部以及容器之间管理数据，数据持久化，有两种方式：数据卷（Volumes）、挂载主机目录（Bind mounts）。&#xA;数据卷 数据卷是一个可以由一个或者多个容器共同使用的特殊目录，实现数据的持久化，他可以被挂载到指定容器的指定目录下。&#xA;特性：&#xA;在容器中可以共享和重用 对数据卷的修改会立马生效 对数据卷的更新，不会影响镜像 数据卷会一致存在，即使容器被删除 # 创建一个数据卷 $ docker volume create my-vol my-vol # 查看所有的数据卷 $ docker volume ls DRIVER VOLUME NAME local 4212c0b85321ee7dec3e5f156533d101a66078bc7eee4c0beac94e6ad3b8f7e8 local my-vol # 查看指定数据卷的信息 $ docker volume inspect my-vol [ { &amp;#34;CreatedAt&amp;#34;: &amp;#34;2023-08-12T14:19:27Z&amp;#34;, &amp;#34;Driver&amp;#34;: &amp;#34;local&amp;#34;, &amp;#34;Labels&amp;#34;: null, &amp;#34;Mountpoint&amp;#34;: &amp;#34;/var/lib/docker/volumes/my-vol/_data&amp;#34;, &amp;#34;Name&amp;#34;: &amp;#34;my-vol&amp;#34;, &amp;#34;Options&amp;#34;: null, &amp;#34;Scope&amp;#34;: &amp;#34;local&amp;#34; } ] # 删除指定的数据卷 $ docker volume rm my-vol my-vol # 删除无主的数据卷 $ docker volume prune 挂载数据卷到容器：</description>
    </item>
    <item>
      <title>Docker容器</title>
      <link>https://blog.laelaps.us/posts/archive/docker/dockercontainer/</link>
      <pubDate>Fri, 14 Jul 2023 22:47:10 +0800</pubDate>
      <guid>https://blog.laelaps.us/posts/archive/docker/dockercontainer/</guid>
      <description>什么是容器？ 容器是镜像运行的实例，我们可以从一个镜像中运行多个容器，容器比传统的虚拟机更快和更轻量级；在采用虚拟机时，我们的虚拟机的软件要将物理资源进行划分，然后分配给每一个虚拟机，他是一种居于硬件虚拟化；而在容器时代，我们的物理资源全部分配给操作系统，我们的容器引擎想操作系统申请资源，每一个容器是一个独立的相互隔离的进程，他可以自动的调整资源的大小，容器是一种居于操作系统的虚拟化。&#xA;启动容器 docker container run &amp;lt;options&amp;gt; &amp;lt;im-age&amp;gt;:&amp;lt;tag&amp;gt; &amp;lt;app&amp;gt; // 启动一个ubuntu docker container run -it ubuntu:20.04 /bin/bash // 或者省去container docker run -it ubuntu:20.04 /bin/sh 当运行docker run时，docker会根据指定的镜像的标签在本地查找，如果查找不到则自动进行pull。然后运行命令指定的程序。&#xA;-t是分配一个伪终端将（pseudo-tty）绑定到容器的标准输入上。 -i是让容器的标准输入保存打开。 退出当前终端使用exit()，容器会停止运行，因为这时候终端是容器唯一运行的程序。 docker使用docker container start来启动一个已经停止的容器；使用docker container restart来将一个运行中的容器重新启动它。 查看容器 docker使用docker container ls来查看当前正在运行的容器，在ls之后添加-a来查看全部的容器，包括已经退出的容器。&#xA;删除容器 我们在查看所有容器后，会发现有许多停止运行的容器，使用docker container rm可以将已经停止运行的容器删除。&#xA;$ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7f87eac41019 ubuntu:20.04 &amp;#34;/bin/bash&amp;#34; 13 minutes ago Exited (0) 6 minutes ago condescending_jennings f412d9c4ff7e ubuntu:20.04 &amp;#34;/bin/sh&amp;#34; 14 minutes ago Exited (0) 7 minutes ago $ docker container rm 7f87eac41019 f412d9c4ff7e 7f87eac41019 f412d9c4ff7e 守护态运行 在之前我们都是的容器都是将输入结果输出到当前的数组的终端上，如果我们想让容器运行在后台上，可以在docker run -d .</description>
    </item>
    <item>
      <title>Docker镜像</title>
      <link>https://blog.laelaps.us/posts/archive/docker/dockerimage/</link>
      <pubDate>Tue, 11 Jul 2023 19:09:44 +0800</pubDate>
      <guid>https://blog.laelaps.us/posts/archive/docker/dockerimage/</guid>
      <description>什么是Docker Docker是一种容器，他对传统的Linux容器进行了封装，简化了他容器的创建和维护；Docker不像传统的虚拟机一样需要虚拟出一层硬件来，他的应用程序直接运行在宿主的内核中，但是运行的进程独立于宿主和其他的容器。&#xA;优势 对资源的更好的利用，不用像传统虚拟机一样虚拟出硬件之后在运行一个完整的系统。 Docker容器应用启动更快，节省时间。（但是我的Docker Desktop启动很慢） 一致的运行环境，Docker 保证了应用运行的环境是一样的，只有宿主的内核不一样。 一次创建和配置，在任意的地方运行。 镜像 镜像类似于一个类，他是创建容器的模板，而且镜像是由多层组成，一层建立在另外一层之上；他包含应用运行所需要的文件和依赖等。&#xA;命名 Docker镜像存储在镜像仓库中，默认的的仓库服务是Docker Hub（Docker维护）。 如果我们只需要给定一个镜像名字和标签（未给定为latest），就能在官方仓库中定位一个镜像；二如果需要从Docker Hub中拉取一个镜像，需要加入Docker Hub的用户名。当然我们还可以拉取第三方仓库的镜像，则需要加入第三方仓库的地址和端口号。&#xA;// 在Docker Hub中拉取 docker pull ubuntu:20.04 // 在Docker Hub中拉取第三方 docker pull bitnami/postgresql:15.3.0 // docker pull quay.io/kiwigrid/k8s-sidecar 分层 Docker镜像由一些松耦合的只读镜像组成，所有的Docker镜像都起源于一个基础镜像层，我们在当前镜像之上创建新的镜像层，我们就可以对新的镜像层进行修改或者增加。 尽管镜像由多层镜像组合而成，但是他们对外还是保存一个镜像文件。 多个镜像共享镜像层，因为有的镜像会依赖相同的镜像层，在这种情况下，如果镜像层已经存在，则不会重新拉取。&#xA;$ docker image inspect mysql:latest ... &amp;#34;RootFS&amp;#34;: { &amp;#34;Type&amp;#34;: &amp;#34;layers&amp;#34;, &amp;#34;Layers&amp;#34;: [ &amp;#34;sha256:9cd9df9ffc972e9abc946d855162ef0c40dff9a89f10c962b7920154a3d943d8&amp;#34;, &amp;#34;sha256:824505732bf475e99d3d9f2d2a1bbcb2f822005a5eb42ed3bd6c90d896601cf6&amp;#34;, &amp;#34;sha256:0b175674497447465ef1a69f9aa74eaad5fc89875eceb9257b1f51723a676b22&amp;#34;, &amp;#34;sha256:824c2933e60c068e80f2aeed3156289d52e173302c9591307186a1901d511747&amp;#34;, &amp;#34;sha256:4645c1089915b7a96108959a038bbabd1a9301561c04884ee25217fbd8529cbd&amp;#34;, &amp;#34;sha256:2dddefc501cc94ee7378f11117eb7537f18e42dff066fd0b0e352579fa201e47&amp;#34;, &amp;#34;sha256:3e8acfe4342fadf5703bc0e57f029aa8645f5bdad6071289b98f33e1b207f522&amp;#34;, &amp;#34;sha256:5f038062397273abd71d4393adf7dbf3b5517e0f2c660054d1bedb1d629e3dd9&amp;#34;, &amp;#34;sha256:16f4176c5cad94a63121b2f4f77a2027f15c8b88559d423daf345a51d41251eb&amp;#34;, &amp;#34;sha256:394c5cd5b4baf7e17088e44077a8b14ecbd9ba5d460629f1efb8ea3a90380a08&amp;#34;, &amp;#34;sha256:e2eaf447bf15d59b9e8f4e7c00c63cf35bf9096403563eed770cd758d27eb557&amp;#34; ] }, .... 标签 用来标记仓库中的镜像，一个镜像能有多个标签。&#xA;拉取 docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] 悬虚镜像 zlmediakit/zlmediakit master 635f082db6f7 7 weeks ago 597MB // 悬虚镜像 ubuntu &amp;lt;none&amp;gt; 1c5c8d0b973a 4 months ago 72.</description>
    </item>
  </channel>
</rss>
