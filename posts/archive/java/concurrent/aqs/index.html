<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="Hugo 0.123.8">

  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="author" content="laelaps" />
  <meta property="og:url" content="https://blog.laelaps.us/posts/archive/java/concurrent/aqs/" />
  <link rel="canonical" href="https://blog.laelaps.us/posts/archive/java/concurrent/aqs/" /><link rel="alternate" type="application/atom+xml" href="https://blog.laelaps.us/index.xml" title="Laelaps">

  <script type="application/ld+json">
  {
      "@context" : "http://schema.org",
      "@type" : "BlogPosting",
      "mainEntityOfPage": {
           "@type": "WebPage",
           "@id": "https:\/\/blog.laelaps.us\/"
      },
      "articleSection" : "posts",
      "name" : "Java AQS",
      "headline" : "Java AQS",
      "description" : "LockSupport LockSupport是JUC包下locks子包下的一个类，同用来在Java中对线程实现一个最基本的阻塞和唤醒。它和CAS一样是在JUC包下并发工具控制的实现基础，他们同样都依赖Unsafe类，依赖该类下的JNI接口。\n基本方法 在LockSupport中使用park开头的方法来阻塞当前线程，unpark方法用来唤醒一个被阻塞的现场。\n\/** * 尝试获取一个许可，如果没有则阻塞当前线程，响应中断；以下情况会返回 * 1.调用unpark(Thread thread)获得许可，这个unpark操作可以在park之前或者之后，如果park之前已经获得了许可，则调用了park会发上返回 * 2.当前线程被中断(interrupt())，返回时不会抛出异常 * 3.因为虚假唤醒而返回 *\/ public static void park() { UNSAFE.park(false, 0L); } \/** * park()的扩展函数，时间是相对当前时间的时间段，单位为纳秒，如果超时自动返回 * * @param nanos 时间段纳秒 *\/ public static void parkNanos(long nanos) { if (nanos \u0026gt; 0) UNSAFE.park(false, nanos); } \/** * park()的扩展函数，时间是基于绝对时间(1970开始)的时间点，单位为毫秒，如果超时自动返回 * * @param deadline 时间点的毫秒值 *\/ public static void parkUntil(long deadline) { UNSAFE.park(true, deadline); } \/** * 提供一个许可，唤醒线程的方法就这一个。 * 1.如果thread 之前没有持有许可，则让thread 线程持有一个，如果这前有许可了，那么数量不会增加 * 2.",
      "inLanguage" : "en-US",
      "author" : "laelaps",
      "creator" : "laelaps",
      "publisher": "laelaps",
      "accountablePerson" : "laelaps",
      "copyrightHolder" : "laelaps",
      "copyrightYear" : "2023",
      "datePublished": "2023-08-14 08:26:03 \u002b0800 \u002b0800",
      "dateModified" : "2023-08-14 08:26:03 \u002b0800 \u002b0800",
      "url" : "https:\/\/blog.laelaps.us\/posts\/archive\/java\/concurrent\/aqs\/",
      "keywords" : [  ]
  }
</script>
<title>Java AQS</title>
  <meta property="og:title" content="Java AQS" />
  <meta property="og:type" content="article" />
  <meta property="og:description" content="LockSupport LockSupport是JUC包下locks子包下的一个类，同用来在Java中对线程实现一个最基本的阻塞和唤醒。它和CAS一样是在JUC包下并发工具控制的实现基础，他们同样都依赖Unsafe类，依赖该类下的JNI接口。
基本方法 在LockSupport中使用park开头的方法来阻塞当前线程，unpark方法用来唤醒一个被阻塞的现场。
/** * 尝试获取一个许可，如果没有则阻塞当前线程，响应中断；以下情况会返回 * 1.调用unpark(Thread thread)获得许可，这个unpark操作可以在park之前或者之后，如果park之前已经获得了许可，则调用了park会发上返回 * 2.当前线程被中断(interrupt())，返回时不会抛出异常 * 3.因为虚假唤醒而返回 */ public static void park() { UNSAFE.park(false, 0L); } /** * park()的扩展函数，时间是相对当前时间的时间段，单位为纳秒，如果超时自动返回 * * @param nanos 时间段纳秒 */ public static void parkNanos(long nanos) { if (nanos &amp;gt; 0) UNSAFE.park(false, nanos); } /** * park()的扩展函数，时间是基于绝对时间(1970开始)的时间点，单位为毫秒，如果超时自动返回 * * @param deadline 时间点的毫秒值 */ public static void parkUntil(long deadline) { UNSAFE.park(true, deadline); } /** * 提供一个许可，唤醒线程的方法就这一个。 * 1.如果thread 之前没有持有许可，则让thread 线程持有一个，如果这前有许可了，那么数量不会增加 * 2." />
  <meta name="description" content="LockSupport LockSupport是JUC包下locks子包下的一个类，同用来在Java中对线程实现一个最基本的阻塞和唤醒。它和CAS一样是在JUC包下并发工具控制的实现基础，他们同样都依赖Unsafe类，依赖该类下的JNI接口。
基本方法 在LockSupport中使用park开头的方法来阻塞当前线程，unpark方法用来唤醒一个被阻塞的现场。
/** * 尝试获取一个许可，如果没有则阻塞当前线程，响应中断；以下情况会返回 * 1.调用unpark(Thread thread)获得许可，这个unpark操作可以在park之前或者之后，如果park之前已经获得了许可，则调用了park会发上返回 * 2.当前线程被中断(interrupt())，返回时不会抛出异常 * 3.因为虚假唤醒而返回 */ public static void park() { UNSAFE.park(false, 0L); } /** * park()的扩展函数，时间是相对当前时间的时间段，单位为纳秒，如果超时自动返回 * * @param nanos 时间段纳秒 */ public static void parkNanos(long nanos) { if (nanos &amp;gt; 0) UNSAFE.park(false, nanos); } /** * park()的扩展函数，时间是基于绝对时间(1970开始)的时间点，单位为毫秒，如果超时自动返回 * * @param deadline 时间点的毫秒值 */ public static void parkUntil(long deadline) { UNSAFE.park(true, deadline); } /** * 提供一个许可，唤醒线程的方法就这一个。 * 1.如果thread 之前没有持有许可，则让thread 线程持有一个，如果这前有许可了，那么数量不会增加 * 2." />
  <meta property="og:locale" content="en-us" /><meta property="og:image" content="" />
  

  
    <style>body{font-family:bree serif,sans-serif;-webkit-font-smoothing:antialiased;margin:0 20px}article{max-width:800px;margin-left:auto;margin-right:auto}a{color:#000;text-decoration:none}a:hover{text-decoration:underline}.post-ads{margin:50px 0}.markdown-body{font-size:18px;max-width:100%}.markdown-body a{text-decoration:none;text-decoration-color:#000}.markdown-body blockquote{margin:0;padding:0 1em;color:#57606a;border-left:.25em solid #d0d7de}.markdown-body a{color:#1bc92a}.markdown-body pre{padding:16px;overflow:auto;border-radius:10px}.markdown-body code{padding:.2em .4em;font-size:85%;background-color:#f6f8fa;border-radius:6px}.markdown-body pre>code{padding:0;font-size:100%;background-color:inherit;border:0}.Chinese .markdown-body{line-height:200%}.site-date-catalog{font-size:2rem}.header-title{font-size:2rem;font-weight:700;margin-top:32px;font-family:bungee shade,sans-serif}.header-title a{text-decoration:none}.header-subtitle{color:#666}.header-items{margin:10px 0}.header-item{margin:0 5px}.header-line{width:100%;border-width:2px;border-color:#482936;border-style:solid none none none}.lang-switch{font-weight:600}#posts-list{min-height:600px}.posts-line{font-size:1.2rem;margin:12px 0}.posts-categories{font-size:.8rem;margin:auto;text-align:center}.posts-category{padding:3px 0;border:#000 2px solid;border-radius:5px}.site-footer{margin-top:50px}.site-footer-item{margin-right:12px}.post-content img{max-width:100%;display:block;margin-right:auto;margin-top:12px}.post-header{margin-bottom:50px}.post-title{font-size:2rem;font-weight:600}.post-tags{display:inline;font-weight:600;padding:2px 5px;margin-right:6px;border:#000 2px solid;border-radius:5px}.post-date{font-weight:800;font-style:italic}.post-author{float:right;font-weight:600}.page-content{min-height:60%}.post-content{margin-bottom:50px}.post-content p{hyphens:auto;line-height:1.8;text-justify:ideographic;margin-bottom:1em}.related-content{border-width:3px;border-style:solid;border-color:#000;padding:0 10px;margin-bottom:50px;margin-top:100px}.related-content li{margin:5px 0}.taxonomy-term{font-size:3rem}.gallery-img{text-align:center}.gallery-img span{text-align:center}.gallery-img-desc{font-size:.8em;font-weight:800}#disqus_thread{position:relative}#disqus_thread:after{content:"";display:block;height:55px;width:100%;position:absolute;bottom:0;background:#fff}@media screen and (max-width:600px){.header-title,.header-subtitle,.header-items{text-align:center}.posts-line{font-size:16px}.markdown-body{font-size:16px}.post-title{font-size:2rem}.post-content p{letter-spacing:.05em}}@media screen and (max-width:48em){.posts-category{display:none}}table{width:100%;border-collapse:collapse;border:1px solid}tr,th,td{border:1px solid;height:40px;padding-left:10px}thead{background:#ebebeb}</style>
  
  
    <style>.container,.container-fluid{margin-right:auto;margin-left:auto}.container-fluid{padding-right:2rem;padding-left:2rem}.row{box-sizing:border-box;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:0;-ms-flex:0 1 auto;flex:initial;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-.5rem;margin-left:-.5rem}.row.reverse{-webkit-box-orient:horizontal;-webkit-box-direction:reverse;-ms-flex-direction:row-reverse;flex-direction:row-reverse}.col.reverse{-webkit-box-orient:vertical;-webkit-box-direction:reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse}.col-xs,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9,.col-xs-offset-0,.col-xs-offset-1,.col-xs-offset-10,.col-xs-offset-11,.col-xs-offset-12,.col-xs-offset-2,.col-xs-offset-3,.col-xs-offset-4,.col-xs-offset-5,.col-xs-offset-6,.col-xs-offset-7,.col-xs-offset-8,.col-xs-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-xs{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-xs-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-xs-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-xs-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-xs-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-xs-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-xs-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-xs-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-xs-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-xs-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-xs-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-xs-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-xs-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-xs-offset-0{margin-left:0}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-11{margin-left:91.66666667%}.start-xs{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-xs{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-xs{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-xs{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-xs{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-xs{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-xs{-ms-flex-pack:distribute;justify-content:space-around}.between-xs{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-xs{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-xs{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}@media only screen and (min-width:48em){.container{width:49rem}.col-sm,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-sm-offset-0,.col-sm-offset-1,.col-sm-offset-10,.col-sm-offset-11,.col-sm-offset-12,.col-sm-offset-2,.col-sm-offset-3,.col-sm-offset-4,.col-sm-offset-5,.col-sm-offset-6,.col-sm-offset-7,.col-sm-offset-8,.col-sm-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-sm{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-sm-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-sm-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-sm-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-sm-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-sm-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-sm-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-sm-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-sm-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-sm-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-sm-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-sm-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-sm-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-sm-offset-0{margin-left:0}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-11{margin-left:91.66666667%}.start-sm{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-sm{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-sm{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-sm{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-sm{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-sm{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-sm{-ms-flex-pack:distribute;justify-content:space-around}.between-sm{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-sm{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-sm{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:64em){.container{width:65rem}.col-md,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-md-offset-0,.col-md-offset-1,.col-md-offset-10,.col-md-offset-11,.col-md-offset-12,.col-md-offset-2,.col-md-offset-3,.col-md-offset-4,.col-md-offset-5,.col-md-offset-6,.col-md-offset-7,.col-md-offset-8,.col-md-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-md{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-md-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-md-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-md-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-md-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-md-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-md-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-md-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-md-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-md-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-md-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-md-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-md-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-md-offset-0{margin-left:0}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-3{margin-left:25%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-6{margin-left:50%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-9{margin-left:75%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-11{margin-left:91.66666667%}.start-md{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-md{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-md{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-md{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-md{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-md{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-md{-ms-flex-pack:distribute;justify-content:space-around}.between-md{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-md{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-md{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:75em){.container{width:76rem}.col-lg,.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-lg-offset-0,.col-lg-offset-1,.col-lg-offset-10,.col-lg-offset-11,.col-lg-offset-12,.col-lg-offset-2,.col-lg-offset-3,.col-lg-offset-4,.col-lg-offset-5,.col-lg-offset-6,.col-lg-offset-7,.col-lg-offset-8,.col-lg-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-lg{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-lg-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-lg-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-lg-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-lg-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-lg-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-lg-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-lg-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-lg-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-lg-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-lg-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-lg-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-lg-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-lg-offset-0{margin-left:0}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-11{margin-left:91.66666667%}.start-lg{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-lg{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-lg{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-lg{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-lg{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-lg{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-lg{-ms-flex-pack:distribute;justify-content:space-around}.between-lg{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-lg{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-lg{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}</style>
  

  

  <link href="/index.xml" rel="alternate" type="application/rss+xml"
    title="Laelaps">
  
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css?family=Bree+Serif|Bungee+Shade" rel="stylesheet">
  
  

  
  
</head>


<body>
  <article class="post " id="article">
    <div class="row">
      <div class="col-xs-12">
        <div class="site-header">
          
<header>
  <div class="header-title">
    <a href="/"
      >Laelaps</a
    >
  </div>
  <div class="header-subtitle">Stay Hungry, Stay Foolish</div>
</header>
<div class="row end-md center-xs header-items">
  
  <div class="header-item">
    <a href="/categories/plan" target="_blank">Plan</a>
  </div>
  
  <div class="header-item">
    <a href="/categories" target="_blank">Categories</a>
  </div>
  
  <div class="header-item">
    <a href="/categories/java" target="_blank">Java</a>
  </div>
  
  <div class="header-item">
    <a href="/categories/go" target="_blank">Go</a>
  </div>
  
  <div class="header-item">
    <a href="/leetcodes" target="_blank">LeetCode</a>
  </div>
  
  <div class="header-item">
    <a href="/about" target="_blank">About Me</a>
  </div>
  
</div>
<div class="row end-xs">
   
</div>
<div class="header-line"></div>

        </div>
        <header class="post-header">
          <h1 class="post-title">Java AQS</h1>
          
          <div class="row post-desc">
            <div class="col-xs-6">
              
              <time class="post-date" datetime=" 2023-08-14 08:26:03 &#43;0800">
                14 Aug 2023
              </time>
              
            </div>
            <div class="col-xs-6">
              
              <div class="post-author">
                <a target="_blank" href="/">@laelaps</a>
              </div>
              
            </div>
          </div>
          
        </header>
        <aside id="toc-container">
          <details>
            <summary>Table of Contents</summary>
            <aside class="toc">
                <nav id="TableOfContents">
  <ul>
    <li><a href="#locksupport">LockSupport</a>
      <ul>
        <li><a href="#基本方法">基本方法</a></li>
        <li><a href="#原理">原理</a></li>
      </ul>
    </li>
    <li><a href="#aqs">AQS</a>
      <ul>
        <li><a href="#原理-1">原理</a>
          <ul>
            <li><a href="#aqs数据结构-node">AQS数据结构 Node</a></li>
            <li><a href="#state-同步状态">State 同步状态</a></li>
            <li><a href="#方法实现">方法实现</a></li>
          </ul>
        </li>
        <li><a href="#aqs理解">AQS理解</a>
          <ul>
            <li><a href="#加入等待分队列">加入等待分队列</a>
              <ul>
                <li><a href="#加入的时机">加入的时机</a></li>
                <li><a href="#加入队列">加入队列</a></li>
                <li><a href="#等待队列中线程被阻塞">等待队列中线程被阻塞</a></li>
                <li><a href="#cancelled状态节点">CANCELLED状态节点</a></li>
              </ul>
            </li>
            <li><a href="#解锁">解锁</a></li>
            <li><a href="#中断恢复执行">中断恢复执行</a></li>
            <li><a href="#juc的应用场景">JUC的应用场景</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
            </aside>
        </details> 
        </aside>

        <div class="post-content markdown-body">
          
          <h1 id="locksupport">LockSupport</h1>
<p>LockSupport是JUC包下locks子包下的一个类，同用来在Java中对线程实现一个最基本的阻塞和唤醒。它和CAS一样是在JUC包下并发工具控制的实现基础，他们同样都依赖Unsafe类，依赖该类下的JNI接口。</p>
<h2 id="基本方法">基本方法</h2>
<p>在LockSupport中使用park开头的方法来阻塞当前线程，unpark方法用来唤醒一个被阻塞的现场。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 尝试获取一个许可，如果没有则阻塞当前线程，响应中断；以下情况会返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 1.调用unpark(Thread thread)获得许可，这个unpark操作可以在park之前或者之后，如果park之前已经获得了许可，则调用了park会发上返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 2.当前线程被中断(interrupt())，返回时不会抛出异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 3.因为虚假唤醒而返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">park</span>() {
</span></span><span style="display:flex;"><span>    UNSAFE.<span style="color:#a6e22e">park</span>(<span style="color:#66d9ef">false</span>, 0L);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * park()的扩展函数，时间是相对当前时间的时间段，单位为纳秒，如果超时自动返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param nanos 时间段纳秒
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">parkNanos</span>(<span style="color:#66d9ef">long</span> nanos) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (nanos <span style="color:#f92672">&gt;</span> 0)
</span></span><span style="display:flex;"><span>        UNSAFE.<span style="color:#a6e22e">park</span>(<span style="color:#66d9ef">false</span>, nanos);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * park()的扩展函数，时间是基于绝对时间(1970开始)的时间点，单位为毫秒，如果超时自动返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param deadline 时间点的毫秒值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">parkUntil</span>(<span style="color:#66d9ef">long</span> deadline) {
</span></span><span style="display:flex;"><span>    UNSAFE.<span style="color:#a6e22e">park</span>(<span style="color:#66d9ef">true</span>, deadline);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 提供一个许可，唤醒线程的方法就这一个。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 1.如果thread 之前没有持有许可，则让thread 线程持有一个，如果这前有许可了，那么数量不会增加
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 2.如果thread 之前因调用park()而被挂起，则调用unpark()后，该线程会被唤醒。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 3.如果thread 之前没有调用park()，则调用unpark()方法后，后续再一次调用park()方法时，其会立刻返回。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param thread
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unpark</span>(Thread thread) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (thread <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>        UNSAFE.<span style="color:#a6e22e">unpark</span>(thread);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为LockSupport的方法不需要有监视器对象也不需要锁就可以执行，那么就不能使用线程监控和分析工具来定位。因此LockSupport中新增了含有阻塞对象的park方法以及一个获取broker的方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* JDK1.6的新方法,除了参数之外其他和park()一样 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 参数：blocker，用来标识当前线程在等待的对象，即记录线程被阻塞时被谁阻塞的,用于线程监控和分析工具来定位 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 根据源码可以看到的是参数blocker是在park之前先通过setBlocker()记录阻塞线程的发起者object，当线程锁被释放后再次清除记录； 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 推荐使用该方法，而不是park(),因为这个函数可以记录阻塞的发起者，如果发生死锁方便查看，在线程dump中会明确看到这个对象 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* @param blocker 与该线程关联的阻塞对象 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">park</span>(Object blocker) { 
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//获取当前线程 </span>
</span></span><span style="display:flex;"><span>	Thread t <span style="color:#f92672">=</span> Thread.<span style="color:#a6e22e">currentThread</span>(); 
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//记录是哪个对象对该线程发起的阻塞操作 </span>
</span></span><span style="display:flex;"><span>	setBlocker(t, blocker); 
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//挂起线程 </span>
</span></span><span style="display:flex;"><span>	UNSAFE.<span style="color:#a6e22e">park</span>(<span style="color:#66d9ef">false</span>, 0L); 
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//执行到这一步,说明线程被唤醒了,此时清除broker </span>
</span></span><span style="display:flex;"><span>	setBlocker(t, <span style="color:#66d9ef">null</span>); 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/** 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 和park(Object blocker)一样，增加了超时时间，单位为纳秒，超时立即返回， 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* @param blocker 与该线程关联的阻塞对象 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* @param nanos 超时时间段 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">parkNanos</span>(Object blocker, <span style="color:#66d9ef">long</span> nanos) { 
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (nanos <span style="color:#f92672">&gt;</span> 0) { 
</span></span><span style="display:flex;"><span>		Thread t <span style="color:#f92672">=</span> Thread.<span style="color:#a6e22e">currentThread</span>(); 
</span></span><span style="display:flex;"><span>		setBlocker(t, blocker); 
</span></span><span style="display:flex;"><span>		UNSAFE.<span style="color:#a6e22e">park</span>(<span style="color:#66d9ef">false</span>, nanos); 
</span></span><span style="display:flex;"><span>		setBlocker(t, <span style="color:#66d9ef">null</span>); 
</span></span><span style="display:flex;"><span>	} 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/** 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 和park(Object blocker)一样，增加了超时时间点，单位为毫秒，超时立即返回 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* @param blocker 与该线程关联的阻塞对象 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* @param deadline 超时时间点 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">parkUntil</span>(Object blocker, <span style="color:#66d9ef">long</span> deadline) {  
</span></span><span style="display:flex;"><span>    Thread t <span style="color:#f92672">=</span> Thread.<span style="color:#a6e22e">currentThread</span>();  
</span></span><span style="display:flex;"><span>    setBlocker(t, blocker);  
</span></span><span style="display:flex;"><span>    U.<span style="color:#a6e22e">park</span>(<span style="color:#66d9ef">true</span>, deadline);  
</span></span><span style="display:flex;"><span>    setBlocker(t, <span style="color:#66d9ef">null</span>);  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/** 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 设置broker的方法，该方法属于LockSupport的私有方法 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* @param t 当前线程 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* @param arg 要设置broker对象 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setBlocker</span>(Thread t, Object arg) {  
</span></span><span style="display:flex;"><span>    U.<span style="color:#a6e22e">putReferenceOpaque</span>(t, PARKBLOCKER, arg);  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/** 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 查看与该线程关联的阻塞对象，如果没有设置blocker就会获取不到 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* @param t 制定线程 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">* @return 阻塞对象 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Object <span style="color:#a6e22e">getBlocker</span>(Thread t) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>)  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException();  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> U.<span style="color:#a6e22e">getReferenceOpaque</span>(t, PARKBLOCKER);  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="原理">原理</h2>
<p>可以简单的看成，每一个线程都与一个许可（permit）关联，park等待并消耗permit，而unpark则为线程提供一个permit，默认一个线程只能有一个permit，无论你调用多少次unpark，那么线程只会有一个permit，当调用park时，如果存在permit的话，那么他就会继续进行运行下去，否则就会阻塞线程并在这里等待permit后在运行；使用LockSupport.park是不需要先获取某个锁对象，也不会抛出InterruptedException异常，被park阻塞的线程处于WATTING状态，而超时park阻塞的线程处于TIMED_WAITING状态。</p>
<h1 id="aqs">AQS</h1>
<p><img src="/images/AQS/AQS.png" alt="AQS">
有颜色的为Method，无颜色的为Attribution。
当我们需要自定同步器时，我们需要重写第一层（API层）的部分方法即可，不需要清楚底层的具体实现。带自定义同步器进行加锁或解锁时，先经过第一层的API进入AQS内部方法，如何经过第二层进行锁的获取，如果获取锁失败，那么进入第三、四层的等待队列处理，但是他们都依赖于第五层的基础数据提供层。</p>
<h2 id="原理-1">原理</h2>
<p>在AQS中，如果被请求的共享资源空闲，那么就将当前请求的线程设置为有效工作线程，并将共享资源设置为锁定状态，如果资源被占用，那么就需要一定的阻塞等待唤醒机制来保证锁的分配。在AQS中这个机制是由CLH队列的变体来实现的，将暂时获取不到锁的线程加入到队列中。</p>
<p>CLH：Craig、Landin and Hagersten队列，是单向链表。</p>
<p>在AQS中的队列是CLH的变体的虚拟双向队列（FIFO），AQS将每一个等待共享资源的线程封装成一个节点来实现锁的分配。</p>
<h3 id="aqs数据结构-node">AQS数据结构 Node</h3>
<p>AQS中最基本的最基本的数据结构为Node，及CLH变体队列中的节点，将请求的队列封装成CLH变体队列中的一个节点。
在Node中线程有两种锁的模式，共享锁和独占锁。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>SHARED</td>
<td>表示线程以共享的模式等待锁</td>
</tr>
<tr>
<td>EXCLUSIVE</td>
<td>表示线程正在以独占的方式等待锁</td>
</tr>
</tbody>
</table>
<p>Node中的方法和属性：</p>
<table>
<thead>
<tr>
<th>方法和属性值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>waitStatus</td>
<td>当前节点在队列中的状态</td>
</tr>
<tr>
<td>thread</td>
<td>表示处于该节点的线程</td>
</tr>
<tr>
<td>prev</td>
<td>前驱指针</td>
</tr>
<tr>
<td>predecessor</td>
<td>返回前驱节点，没有的话抛出NPE</td>
</tr>
<tr>
<td>nextWaiter</td>
<td>指向下一个处于CONDITION状态的节点</td>
</tr>
<tr>
<td>next</td>
<td>后继指针</td>
</tr>
</tbody>
</table>
<p>waitStatus有带选的枚举值：</p>
<table>
<thead>
<tr>
<th>枚举</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>当一个Node被初始化的时候的默认值</td>
</tr>
<tr>
<td>CANCELLED</td>
<td>为1，表示线程获取锁的请求已经取消了</td>
</tr>
<tr>
<td>CONDITION</td>
<td>为-2，表示节点在等待队列中，节点线程等待唤醒</td>
</tr>
<tr>
<td>PROPAGATE</td>
<td>为-3，当前线程处在SHARED情况下，该字段才会使用</td>
</tr>
<tr>
<td>SIGNAL</td>
<td>为-1，表示线程已经准备好了，就等资源释放了</td>
</tr>
</tbody>
</table>
<h3 id="state-同步状态">State 同步状态</h3>
<p>在AQS中有一个state的字段，为同步状态，由Volatile修饰，表示当前临界资源的获锁情况；我们在定义同步工具时，需要自定义获取同步状态和释放同步状态的方式，API层实现。</p>
<p>访问state方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>protected final int getState()</td>
<td>获取State的值</td>
</tr>
<tr>
<td>protected final void setState(int newState)</td>
<td>设置State的值</td>
</tr>
<tr>
<td>protected final boolean compareAndSetState(int expect, int update)</td>
<td>使用CAS方式更新State</td>
</tr>
</tbody>
</table>
<p>通过State字段来实现多线程的独占模式和共享模式：
<img src="/images/AQS/exclusiveState.png" alt="exclusiveState">
<img src="/images/AQS/shareState.png" alt="shareState"></p>
<h3 id="方法实现">方法实现</h3>
<p>我们在自定义同步器时，需要实现同步器中的方法，也就是通过修改State字段来实现多线程的独占模式或者共享模式。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>protected boolean isHeldExclusively()</td>
<td>该线程是否正在独占资源。只有用到Condition才需要去实现它。</td>
</tr>
<tr>
<td>protected boolean tryAcquire(int arg)</td>
<td>独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。</td>
</tr>
<tr>
<td>protected boolean tryRelease(int arg)</td>
<td>独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。</td>
</tr>
<tr>
<td>protected int tryAcquireShared(int arg)</td>
<td>共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</td>
</tr>
<tr>
<td>protected boolean tryReleaseShared(int arg)</td>
<td>共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。</td>
</tr>
</tbody>
</table>
<p>这些方法不是全部都要实现，如果我们需要的独占锁，那么只需要实现tryAcquire-tryRelease，共享锁需要实现tryAcquireShared-tryReleaseShared，当然也有同时实现独占和共享两种方式的，如ReentrantReadWriteLock。</p>
<p>Lock类跟API层核心方法的映射关系：
<img src="/images/AQS/LockPro.png" alt="lock">
接下来的分析都是根据ReentrantLock来分析AQS</p>
<h2 id="aqs理解">AQS理解</h2>
<p>在这里我们根据ReentrantLock来理解AQS，在ReentrantLock中有公平锁和非公平两种，但是两种在底层是相同的。（以下在Java11中的源码中分析，并且为ReetrantLock作为代表）</p>
<p>公平锁、非公平锁实现的lock方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span>() {  
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 直接进入到AQS中</span>
</span></span><span style="display:flex;"><span>    acquire(1);  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>然后直接进入到AQS中的acquire方法中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">acquire</span>(<span style="color:#66d9ef">int</span> arg) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tryAcquire(arg) <span style="color:#f92672">&amp;&amp;</span>  
</span></span><span style="display:flex;"><span>        acquireQueued(addWaiter(Node.<span style="color:#a6e22e">EXCLUSIVE</span>), arg))  
</span></span><span style="display:flex;"><span>        selfInterrupt();  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在acquire中会调用需要我们自定义的tryAcquire方法。</p>
<p>公平锁实现的tryAcquire方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquire</span>(<span style="color:#66d9ef">int</span> acquires) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> Thread current <span style="color:#f92672">=</span> Thread.<span style="color:#a6e22e">currentThread</span>();  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> getState();  
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获取到State状态后，判断锁是否被其他线程拥有</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> 0) {  
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 当前锁没有被共享,且AQS队列中没有等待的线程，尝试获取锁</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>hasQueuedPredecessors() <span style="color:#f92672">&amp;&amp;</span>  
</span></span><span style="display:flex;"><span>            compareAndSetState(0, acquires)) {  
</span></span><span style="display:flex;"><span>            setExclusiveOwnerThread(current);  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (current <span style="color:#f92672">==</span> getExclusiveOwnerThread()) {  
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 当前线程重入</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> nextc <span style="color:#f92672">=</span> c <span style="color:#f92672">+</span> acquires;  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (nextc <span style="color:#f92672">&lt;</span> 0)  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#34;Maximum lock count exceeded&#34;</span>);  
</span></span><span style="display:flex;"><span>        setState(nextc);  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>非公平锁实现的tryAcquire方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquire</span>(<span style="color:#66d9ef">int</span> acquires) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> nonfairTryAcquire(acquires);  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// java.util.cocurrent.locks.ReetrantLock$Sync</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">nonfairTryAcquire</span>(<span style="color:#66d9ef">int</span> acquires) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> Thread current <span style="color:#f92672">=</span> Thread.<span style="color:#a6e22e">currentThread</span>();  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> getState();  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> 0) {  
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 锁没有被共享，不判断AQS队列中是否有等待的现场，直接尝试获取锁</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (compareAndSetState(0, acquires)) {  
</span></span><span style="display:flex;"><span>            setExclusiveOwnerThread(current);  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (current <span style="color:#f92672">==</span> getExclusiveOwnerThread()) {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> nextc <span style="color:#f92672">=</span> c <span style="color:#f92672">+</span> acquires;  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (nextc <span style="color:#f92672">&lt;</span> 0) <span style="color:#75715e">// overflow  </span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> Error(<span style="color:#e6db74">&#34;Maximum lock count exceeded&#34;</span>);  
</span></span><span style="display:flex;"><span>        setState(nextc);  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>公平锁和非公平锁在代码中的表现为，是否会去AQS等待队列中判断是否有等待的线程。</p>
<h3 id="加入等待分队列">加入等待分队列</h3>
<h4 id="加入的时机">加入的时机</h4>
<p>在执行AQS的acquire方法时，会通过tryAcquire获取锁，如果未获取到锁，就会执行addWaiter将线程加入到AQS等待队列中去。</p>
<h4 id="加入队列">加入队列</h4>
<p>执行addWaiter方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// mode – Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">addWaiter</span>(Node mode) {  
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 将当前线程封装成一个Node节点</span>
</span></span><span style="display:flex;"><span>    Node node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node(mode);  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (;;) { 
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e">// 获取尾节点 </span>
</span></span><span style="display:flex;"><span>        Node oldTail <span style="color:#f92672">=</span> tail;  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (oldTail <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {  
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 尾节点不为空</span>
</span></span><span style="display:flex;"><span>            node.<span style="color:#a6e22e">setPrevRelaxed</span>(oldTail);  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (compareAndSetTail(oldTail, node)) {  
</span></span><span style="display:flex;"><span>                oldTail.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node;  
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> node;  
</span></span><span style="display:flex;"><span>            }  
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {  
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 尾节点为空，开始初始化同步队列</span>
</span></span><span style="display:flex;"><span>            initializeSyncQueue();  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">initializeSyncQueue</span>() {  
</span></span><span style="display:flex;"><span>    Node h;  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (HEAD.<span style="color:#a6e22e">compareAndSet</span>(<span style="color:#66d9ef">this</span>, <span style="color:#66d9ef">null</span>, (h <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node())))  
</span></span><span style="display:flex;"><span>        tail <span style="color:#f92672">=</span> h;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 尾节点的CAS操作</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">compareAndSetTail</span>(Node expect, Node update) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> TAIL.<span style="color:#a6e22e">compareAndSet</span>(<span style="color:#66d9ef">this</span>, expect, update);  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>将当前线程封装成一个节点。</li>
<li>开始循环将当前节点加入到等待队列的末尾。</li>
<li>判断当尾节点是否为空。
<ul>
<li>为空，进入到initializeSyncQueue初始化一个带有空节点的队列。
<img src="/images/AQS/queue/Q1.png" alt="Q1.png"></li>
<li>不为空，首先将当前节点的prev设置为前置节点。
<ul>
<li>如果设置尾节点的CAS操作成功，将前前置节点的next设置为当前节点</li>
<li>如果CAS失败，tail已经重新被其他线程修改，那么进行自旋，直到将节点成功加入到等待队列中。
<img src="/images/AQS/queue/Q2.png" alt="Q1.png"></li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="等待队列中线程被阻塞">等待队列中线程被阻塞</h4>
<p>addWaiter方法会把对应的线程封装到Node数据结构中，然后加入双端队列，返回的Node会作为参数进入到acquireQueued方法中，线程将会在队列中获取锁的操作；acquireQueued会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">acquireQueued</span>(<span style="color:#66d9ef">final</span> Node node, <span style="color:#66d9ef">int</span> arg) {  
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 标记等待过程中是否被中断</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> interrupted <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {  
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 自旋，不断获取锁</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (;;) {  
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 获取当前节点的前驱节点</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">final</span> Node p <span style="color:#f92672">=</span> node.<span style="color:#a6e22e">predecessor</span>();  
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 前驱节点是头节点，同时获取到锁</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> head <span style="color:#f92672">&amp;&amp;</span> tryAcquire(arg)) {  
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 将当前节点设置为头节点</span>
</span></span><span style="display:flex;"><span>                setHead(node);  
</span></span><span style="display:flex;"><span>                p.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>; <span style="color:#75715e">// help GC  </span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> interrupted;  
</span></span><span style="display:flex;"><span>            }  
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// p不为头节点，或者p为头节点，但是没有获取到锁</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 这时需要判断当前节点是否要被阻塞，需要更加前驱节点的状态来确定，</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 只有当前驱节点的waitStatus=-1是才能阻塞当前节点</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (shouldParkAfterFailedAcquire(p, node))  
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 阻塞当前节点</span>
</span></span><span style="display:flex;"><span>                interrupted <span style="color:#f92672">|=</span> parkAndCheckInterrupt();  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (Throwable t) {  
</span></span><span style="display:flex;"><span>        cancelAcquire(node);  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (interrupted)  
</span></span><span style="display:flex;"><span>            selfInterrupt();  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> t;  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将节点设置为头节点</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setHead</span>(Node node) {  
</span></span><span style="display:flex;"><span>    head <span style="color:#f92672">=</span> node;  
</span></span><span style="display:flex;"><span>    node.<span style="color:#a6e22e">thread</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;  
</span></span><span style="display:flex;"><span>    node.<span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将当前节点阻塞</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">parkAndCheckInterrupt</span>() {  
</span></span><span style="display:flex;"><span>    LockSupport.<span style="color:#a6e22e">park</span>(<span style="color:#66d9ef">this</span>);  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Thread.<span style="color:#a6e22e">interrupted</span>();  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>shouldParkAfterFailedAcquire函数分析：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">shouldParkAfterFailedAcquire</span>(Node pred, Node node) {  
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// pred节点状态，即node前驱节点状态</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ws <span style="color:#f92672">=</span> pred.<span style="color:#a6e22e">waitStatus</span>;  
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// pred节点处于唤醒状态</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ws <span style="color:#f92672">==</span> Node.<span style="color:#a6e22e">SIGNAL</span>)  
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * This node has already set status asking a release         
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * to signal it, so it can safely park.         
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>        
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;  
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// pred节点处于取消状态</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ws <span style="color:#f92672">&gt;</span> 0) {  
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Predecessor was cancelled. Skip over predecessors and         
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * indicate retry.         
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>        
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 循环向前查找被取消的节点，把取消节点从队列中删除</span>
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">do</span> {  
</span></span><span style="display:flex;"><span>            node.<span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> pred <span style="color:#f92672">=</span> pred.<span style="color:#a6e22e">prev</span>;  
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">while</span> (pred.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&gt;</span> 0);  
</span></span><span style="display:flex;"><span>        pred.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node;  
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*  
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * waitStatus must be 0 or PROPAGATE.  Indicate that we         
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * need a signal, but don&#39;t park yet.  Caller will need to         
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * retry to make sure it cannot acquire before parking.         
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>        
</span></span><span style="display:flex;"><span>		 <span style="color:#75715e">// 将pred的等待状态设置为SIGNAL</span>
</span></span><span style="display:flex;"><span>         pred.<span style="color:#a6e22e">compareAndSetWaitStatus</span>(ws, Node.<span style="color:#a6e22e">SIGNAL</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="cancelled状态节点">CANCELLED状态节点</h4>
<p>通过cancelAcquire方法，可以将Node节点的状态标记为CANCELLED。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cancelAcquire</span>(Node node) {  
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 无效节点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>)  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;  
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 将当前节点置为虚节点</span>
</span></span><span style="display:flex;"><span>    node.<span style="color:#a6e22e">thread</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 跳过所有的被取消的节点</span>
</span></span><span style="display:flex;"><span>    Node pred <span style="color:#f92672">=</span> node.<span style="color:#a6e22e">prev</span>;  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (pred.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&gt;</span> 0)  
</span></span><span style="display:flex;"><span>        node.<span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> pred <span style="color:#f92672">=</span> pred.<span style="color:#a6e22e">prev</span>;  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获取过滤后前驱节点的后继节点</span>
</span></span><span style="display:flex;"><span>    Node predNext <span style="color:#f92672">=</span> pred.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 将当前节点设置为CANCELLED状态</span>
</span></span><span style="display:flex;"><span>	node.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">=</span> Node.<span style="color:#a6e22e">CANCELLED</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 当前节点是尾节点，将从后往前的第一个非取消状态的节点设置为尾节点，即pred</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果CAS成功，将Tail的后继节点设置为null</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 没有CAS成功，说明有新加入的节点，进入到else部分</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node <span style="color:#f92672">==</span> tail <span style="color:#f92672">&amp;&amp;</span> compareAndSetTail(node, pred)) {  
</span></span><span style="display:flex;"><span>        pred.<span style="color:#a6e22e">compareAndSetNext</span>(predNext, <span style="color:#66d9ef">null</span>);  
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {  
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> ws;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (pred <span style="color:#f92672">!=</span> head <span style="color:#f92672">&amp;&amp;</span>  
</span></span><span style="display:flex;"><span>            ((ws <span style="color:#f92672">=</span> pred.<span style="color:#a6e22e">waitStatus</span>) <span style="color:#f92672">==</span> Node.<span style="color:#a6e22e">SIGNAL</span> <span style="color:#f92672">||</span>  
</span></span><span style="display:flex;"><span>             (ws <span style="color:#f92672">&lt;=</span> 0 <span style="color:#f92672">&amp;&amp;</span> pred.<span style="color:#a6e22e">compareAndSetWaitStatus</span>(ws, Node.<span style="color:#a6e22e">SIGNAL</span>))) <span style="color:#f92672">&amp;&amp;</span>  
</span></span><span style="display:flex;"><span>            pred.<span style="color:#a6e22e">thread</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {  
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 当前节点不是head的后继节点</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 1. 当前节点的前驱节点是否为SIGNAL</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 2. 前驱节点的状态为0，将前驱节点的状态设置为SIGNAL</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 前驱节点thread不为null </span>
</span></span><span style="display:flex;"><span>            Node next <span style="color:#f92672">=</span> node.<span style="color:#a6e22e">next</span>;  
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 后继节点存在且后继节点不被CANCELLED</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (next <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> next.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&lt;=</span> 0)  
</span></span><span style="display:flex;"><span>                pred.<span style="color:#a6e22e">compareAndSetNext</span>(predNext, next);  
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {  
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 当前节点是head的后继节点</span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 上面条件不满足</span>
</span></span><span style="display:flex;"><span>            unparkSuccessor(node);  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>        node.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node; <span style="color:#75715e">// help GC  </span>
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>可以注意到，在前面我们并没有对Prev指针操作，因为在执行cancelAcquire的时候，当前节点的的前置节点可能已经从队列中除去了，因为在shouldParkAfterFailedAcquire的方法中，已经对Prev指针处理过了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span> <span style="color:#66d9ef">do</span> {  
</span></span><span style="display:flex;"><span>    node.<span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> pred <span style="color:#f92672">=</span> pred.<span style="color:#a6e22e">prev</span>;  
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">while</span> (pred.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&gt;</span> 0);  
</span></span></code></pre></div><h3 id="解锁">解锁</h3>
<p>解锁时所有的都是相同的，并不进行区分。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// java.util.concurrent.locks.ReentrantLock</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlock</span>() {  
</span></span><span style="display:flex;"><span>    sync.<span style="color:#a6e22e">release</span>(1);  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// java.util.concurrent.locks.AbstractQueuedSynchronizer</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">release</span>(<span style="color:#66d9ef">int</span> arg) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (tryRelease(arg)) {  
</span></span><span style="display:flex;"><span>        Node h <span style="color:#f92672">=</span> head;  
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 头节点不为空，且头节点的不是初始化节点，解除线程的挂起状态</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (h <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> h.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">!=</span> 0)  
</span></span><span style="display:flex;"><span>            unparkSuccessor(h);  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>h == null Head还没初始化</li>
<li>h != null &amp;&amp; waitStatus == 0 后继节点还在运行当中，不需要唤醒</li>
<li>h != null &amp;&amp; waitStatus &lt; 0 后继节点被阻塞，需要唤醒
我们需要去实现对应的tryRelease方法。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// java.util.concurrent.locks.ReentrantLock.Sync</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 返回当前锁是不是没有被线程持有</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryRelease</span>(<span style="color:#66d9ef">int</span> releases) {  
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 减少重入次数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> getState() <span style="color:#f92672">-</span> releases;  
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 当前现场不是持有有的线程</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Thread.<span style="color:#a6e22e">currentThread</span>() <span style="color:#f92672">!=</span> getExclusiveOwnerThread())  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalMonitorStateException();  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> free <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;  
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 持有锁的线程全部被释放，将独占锁线程设置为null</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> 0) {  
</span></span><span style="display:flex;"><span>        free <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;  
</span></span><span style="display:flex;"><span>        setExclusiveOwnerThread(<span style="color:#66d9ef">null</span>);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>    setState(c);  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> free;  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>unparkSuccessor方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// 唤醒线程</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unparkSuccessor</span>(Node node) {  
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 当前线程的状态</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ws <span style="color:#f92672">=</span> node.<span style="color:#a6e22e">waitStatus</span>;  
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 当前线程的状态为SIGNAL</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ws <span style="color:#f92672">&lt;</span> 0)  
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 将当前节点状态设置为0</span>
</span></span><span style="display:flex;"><span>        node.<span style="color:#a6e22e">compareAndSetWaitStatus</span>(ws, 0);  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 获取当前节点的下一个节点</span>
</span></span><span style="display:flex;"><span>    Node s <span style="color:#f92672">=</span> node.<span style="color:#a6e22e">next</span>;  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 下一个节点是null或者下一个节点被CANCELLED</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 找到队列最开始的非CANCELLED的节点 	</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (s <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> s.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&gt;</span> 0) {  
</span></span><span style="display:flex;"><span>        s <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;  
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 从队列尾部开始寻找，找到队列中第一个waitStatus&lt;0的节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (Node p <span style="color:#f92672">=</span> tail; p <span style="color:#f92672">!=</span> node <span style="color:#f92672">&amp;&amp;</span> p <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>; p <span style="color:#f92672">=</span> p.<span style="color:#a6e22e">prev</span>)  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (p.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&lt;=</span> 0)  
</span></span><span style="display:flex;"><span>                s <span style="color:#f92672">=</span> p;  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果当前节点的下一个节点不为空且状态&lt;=0,则把当前节点线程唤醒</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (s <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>)  
</span></span><span style="display:flex;"><span>        LockSupport.<span style="color:#a6e22e">unpark</span>(s.<span style="color:#a6e22e">thread</span>);  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>为什么要从后往前找到第一个非CANCELLED的节点呢？</p>
<ol>
<li>因为节点入队并不是原子操作，在addWaiter方法中，<code>node.setPrevRelaxed(oldTail);</code> 和<code>compareAndSetTail(oldTail, node)</code>看作是Tail入队的原子操作，但是这时<code>oldTail.next = node;</code>可能并没有执行，所以是无法从前往后找的。</li>
<li>在产生CANCELLED状态的时候，他是先断开的Next指针，Prev指针并没有断开，因此也需要从后往前遍历才能够遍历完全部的节点。</li>
</ol>
<h3 id="中断恢复执行">中断恢复执行</h3>
<p>在线程被唤醒后他会判断当前线程是否被中断。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">parkAndCheckInterrupt</span>() {  
</span></span><span style="display:flex;"><span>    LockSupport.<span style="color:#a6e22e">park</span>(<span style="color:#66d9ef">this</span>);  
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 返回当前线程的中断状态，并清除</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> Thread.<span style="color:#a6e22e">interrupted</span>();  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但返回到acquireQueued的时候，他会修改interrupted的状态，无论他返回的False or True，他都继续循环直到获取锁，如果获取锁，他会把interrupted返回，如果发生异常，那么他可以在catch中判断线程是否被中断。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">acquireQueued</span>(<span style="color:#66d9ef">final</span> Node node, <span style="color:#66d9ef">int</span> arg) {  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> interrupted <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (;;) {  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">final</span> Node p <span style="color:#f92672">=</span> node.<span style="color:#a6e22e">predecessor</span>();  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> head <span style="color:#f92672">&amp;&amp;</span> tryAcquire(arg)) {  
</span></span><span style="display:flex;"><span>                setHead(node);  
</span></span><span style="display:flex;"><span>                p.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>; <span style="color:#75715e">// help GC  </span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> interrupted;  
</span></span><span style="display:flex;"><span>            }  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (shouldParkAfterFailedAcquire(p, node))  
</span></span><span style="display:flex;"><span>                interrupted <span style="color:#f92672">|=</span> parkAndCheckInterrupt();  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (Throwable t) {  
</span></span><span style="display:flex;"><span>        cancelAcquire(node);  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (interrupted)  
</span></span><span style="display:flex;"><span>            selfInterrupt();  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> t;  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>如果<code>interrupted == True</code>，则会执行selfInterrupt函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">selfInterrupt</span>() {  
</span></span><span style="display:flex;"><span>    Thread.<span style="color:#a6e22e">currentThread</span>().<span style="color:#a6e22e">interrupt</span>();  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>为什么线程获取锁之后还要中断线程呢？（Java协作式中断）</p>
<ol>
<li>中断线程被唤醒时，并不知道被唤醒的原因。可能是线程在等待时被中断，也有可能是释放了锁之后被唤醒，因此我们通过<code>Thread.interrupted()</code>方法检查中断标记，并将标记设置为False，并记录下来，如果线程被中断过，那就在中断过一次。</li>
<li>线程在等待资源的过程中，唤醒后会不断去尝试获取锁，直到抢到锁为止，在这个过程中，并不相应中断，只记录中断状态；在抢到锁后返回，如果被中断过的话，就需要补充一次中断。</li>
</ol>
<h3 id="juc的应用场景">JUC的应用场景</h3>
<table>
<thead>
<tr>
<th>同步工具</th>
<th>同步工具与AQS的关联</th>
</tr>
</thead>
<tbody>
<tr>
<td>ReentrantLock</td>
<td>使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</td>
</tr>
<tr>
<td>Semaphore</td>
<td>使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。</td>
</tr>
<tr>
<td>CountDownLatch</td>
<td>使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。</td>
</tr>
<tr>
<td>ReentrantReadWriteLock</td>
<td>使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。</td>
</tr>
<tr>
<td>ThreadPoolExecutor</td>
<td>Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。</td>
</tr>
</tbody>
</table>

        </div>

        <div class="row middle-xs">
          <div class="col-xs-12">
            
          </div>
        </div>
        
        <div class="row">
          <div class="col-xs-12">
            
          </div>
        </div>

        



        
        
        <div style="height: 50px;"></div>
        
        

        <div class="site-footer">
  
  
</div>

      </div>
    </div>
  </article>

  

<script>
  
  
    
    
  
</script>

  

</body>

</html>